\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[portuguese]{babel}
\usepackage[a4paper, total={7in, 9in}]{geometry}
\usepackage{graphicx}
\usepackage{float}
\usepackage{verbatim}
\usepackage{fancyvrb}
\usepackage[bottom]{footmisc}
\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref}
\usepackage[style=numeric]{biblatex}
\usepackage{hyperref}
\usepackage{mathtools}
\usepackage[title]{appendix}
\usepackage{xcolor}
\usepackage{minted}
\usepackage{csquotes}
\usepackage{framed}

\addbibresource{references.bib}

\begin{document}

{
\center
\begin{figure}[H]
        \centering
        \includegraphics[width=3cm]{Pictures/UM_EENG.jpg}
\end{figure}
\textsc{\Large Universidade do Minho} \\ [0.5cm]
\textsc{\Large Mestrado em Engenharia Informática} \\ [0.5cm]
\textsc{\large Processamento e Representação de Conhecimento} \\ [0.5cm]

{\LARGE \bfseries Musike - Music Linked} \\[0.5cm]

\begin{tabular}{c} 
    José Carlos Lima Martins \\
    A78821 \\
\end{tabular} \\[0.5cm]

\today \\[1cm]
}

\section{Introdução}

ENTREGA:\\
27 de Maio\\

\section{Contextualização}

O trabalho a desenvolver passa por escolher uma área/tema de trabalho. Com esse tema em vista, criar/construir/limpar/extrair um dataset com informação envolvendo tal tema e que esteja disponível na LOD (\textit{Linked Open Data}). Este dataset em Turtle (\textit{Terse RDF Triple Language}) será armazenado em \textit{GraphDB}, onde será possível aceder/realizar queries ao dataset localmente.

De seguida, será criado um website/app web de forma a explorar o dataset anteriormente criado. Este website deve possuir autenticação, usando para isso o \textit{MongoDB}.

\section{Tema escolhido - \textbf{Musike}}

O \textbf{Musike}, abreviatura de \textit{Music Linked}, consiste num website com a informação de artistas, bem como, das suas músicas e dos seus albuns. Em termos de informação a apresentar, pretende-se o seguinte:
\begin{itemize}
    \item Artista
        \begin{itemize}
            \item nome
            \item alias
            \item tipo de artista (Grupo, Pessoa, etc)
            \item data de nascimento/inicio
            \item data de falecimento/fim
            \item sexo (não é aplicável a todos os tipos de artista)
            \item nacionalidade (obtido através da área)
            \item descrição
            \item relações com outros artistas, com músicas e com albuns
            \item urls para página pessoal, redes sociais, etc
            \item classificação dos utilizadores do website
            \item soma das visualizações das várias músicas
        \end{itemize}
    \item Album
        \begin{itemize}
            \item título
            \item data do primeiro release
            \item artista(s)
            \item descrição
            \item músicas do album
            \item tipos (tags) do album (clássica, rock, etc)
            \item relações com artistas e com outros albuns
            \item urls sobre o album
            \item classificação dos utilizadores do website
            \item soma das visualizações das várias músicas
        \end{itemize}
    \item Música
        \begin{itemize}
            \item título
            \item artista(s)
            \item duração
            \item descrição
            \item língua(s)
            \item tipos (tags) da música (clássica, rock, etc)
            \item relações com outras músicas e com artista
            \item urls sobre a música
            \item classificação dos utilizadores do website
            \item número de vezes ouvida pelos utilizadores do website
        \end{itemize}
    \item Área
        \begin{itemize}
            \item nome
            \item tipo (país, cidade, etc)
            \item alias
            \item data de creação
            \item data de fim
            \item descrição
            \item urls sobre a área
            \item relações com outas áreas, pois uma área pode ser parte de outra e, vice-versa, uma área pode incluir várias áreas
        \end{itemize}
\end{itemize}

Para além disso, para cada música o objetivo é ter na sua página o video presente no \textit{YouTube} bem como a letra da música. Com isto, pretende-se que por cada visualização do video se conte que a música foi ouvida uma vez.

Por outro lado, o website deve permitir aos utilizadores escolher as músicas e albuns que mais gosta, bem como, puder criar playlists.

Cada utilizador deve ter acesso às suas estatisticas, onde deve estar presente as músicas que o utilizador ouve mais, os artistas que ouve mais e os albuns que ouve mais.

Por fim, apresentar estatísticas gerais do website entre as quais:
\begin{itemize}
    \item músicas mais ouvidas pelos utilizadores
    \item artistas mais ouvidos pelos utilizadores
    \item tipos de músicas (tags) mais ouvidos pelos utilizadores
    \item albuns mais ouvidos pelos utilizadores
    \item paises com mais artistas
    \item paises com mais músicas
    \item paises com mais albuns
    \item paises mais ``ouvidos'' pelos utilizadores
\end{itemize}

De forma adicional, seria interessante dar sugestões ao utilizador de músicas a ouvir a partir das estatisticas do utilizador.

\section{Parte Estrutural da Ontologia}

Portanto, a partir do que se pretende construir e tendo já em ideia o dataset a ser usado (\textit{MusicBrainz}~\cite{mbSchema}) foi construída a seguinte estrutura:

\begin{figure}[H]
    \centering
    \includegraphics[width=15cm]{Pictures/ontologySctructure.png}
    \caption{Estrutura da ontologia, imagem obtida através de \protect\href{http://www.visualdataweb.de/webvowl/}{WebVOWL}}
\end{figure}

As classes principais são \textit{Artist}, \textit{Recording}, \textit{Album} e \textit{Area} que representam respetivamente Artista, Música, Album e Área. Uma classe também importante mas secundária, é \textit{URL} que reprensenta URL's. Por forma a organizar melhor as propriedades, visto que as subclasses herdam as propriedades/relações das superclasses, foram criadas as superclasses \textit{Entity}, \textit{MusicEntity} e \textit{TimeLimitedEntity}. \textit{MusicEntity} inclui as subclasses \textit{Recording} e \textit{Album} devido às duas possuirem a propriedade \textit{title}. Por outro lado, \textit{TimeLimitedEntity} tem como subclasses \textit{Artist} e \textit{Area}, visto que estas duas classes possuem uma data de inicio e de fim. Já a classe \textit{Entity} inclui as subclasses \textit{MusicEntity} e \textit{TimeLimitedEntity}, ou seja, é a superclasse das quatro principais classes, até porque estas quatro classes possuem as propriedades \textit{about} e \textit{disambiguation}.

Quanto às propriedades/relações a ontologia apresenta as seguintes:
\begin{itemize}
    \item Propriedades (\textit{Data Properties})
    \begin{itemize}
        \item Classe \textbf{\textit{Entity}}
        \begin{itemize}
            \item \textbf{\textit{about}}: Descrição do elemento
            \item \textbf{\textit{disambiguation}}: Forma de disambiguar entre elementos com o mesmo nome
        \end{itemize}
        \item Classe \textbf{\textit{URL}}
        \begin{itemize}
            \item \textbf{\textit{label}}: o nome do website a que se refere o URL (exe: wikipédia)
            \item \textbf{\textit{value}}: URL propriamente dito
        \end{itemize}
        \item Classe \textbf{\textit{TimeLimitedEntity}}
        \begin{itemize}
            \item \textbf{\textit{name}}: Nome do elemento
            \item \textbf{\textit{alias}}: nomes alternativos e nomes com erros ortográficos, permitindo uma melhor busca quando o utilizador introduz o nome com erros 
            \item \textbf{\textit{type}}: Tipo do elemento (em \textit{Area}: district, contry, city, etc, já em \textit{Artist}: person, group, choir, etc)
            \item \textbf{\textit{beginDate}}: Data de ínicio
            \item \textbf{\textit{endDate}}: Data de fim
        \end{itemize}
        \item Classe \textbf{\textit{MusicEntity}}
        \begin{itemize}
            \item \textbf{\textit{title}}: Título
        \end{itemize}
        \item Classe \textbf{\textit{Album}}
        \begin{itemize}
            \item \textbf{\textit{firstReleaseDate}}: Data da primeira ``release'' do Album
        \end{itemize}
        \item Classe \textbf{\textit{Recording}}
        \begin{itemize}
            \item \textbf{\textit{duration}}: Duração da música
            \item \textbf{\textit{language}}: Língua da música
            \item \textbf{\textit{tag}}: Tags (tipos) da música
        \end{itemize}
        \item Classe \textbf{\textit{Artist}}
        \begin{itemize}
            \item \textbf{\textit{gender}}: Género do artista
            \item \textbf{\textit{sortName}}: Nome de modo a ordenar o artista numa lista
        \end{itemize}
    \end{itemize}
    \item Relações (\textit{Object Properties})
    \begin{itemize}
        \item \textbf{\textit{from}}: De \textit{Arist} para \textit{Area}, indica que um artista é da área
        \item \textbf{\textit{hasURL}}: De \textit{Entity} para \textit{URL}, indica que uma entidade tem o URL
        \item \textbf{\textit{hasPart}}: De \textit{Area} para \textit{Area}, indica que uma área inclui a outra
        \item \textbf{\textit{partOf}}: Inverso de \textit{hasPart}, indica que uma área é parte de outra
        \item \textbf{\textit{artistCredit}}: De \textit{Recording} para \textit{Artist}, indica que a música tem como crédito o artista
        \item \textbf{\textit{hasCreditIn}}: Inverso de \textit{artistCredit}, indica que um artista tem crédito na música
        \item \textbf{\textit{hasTrack}}: De \textit{Album} para \textit{Recording}, indica que um album tem a música
        \item \textbf{\textit{trackIn}}: Inverso de \textit{hasTrack}, indica que uma música pertence a um album
    \end{itemize}
\end{itemize}

É importante voltar a referir que as subclasses herdam as propriedades das superclasses.

\section{De JSON para Turtle - Povoamento da Ontologia}

Com a estrutura da ontologia e com uma ideia de que informação seria necessária, foi então usado um dataset (\url{http://ftp.musicbrainz.org/pub/musicbrainz/data/json-dumps/20190403-001001/}) para popular a ontologia. Este dataset é proveniente do \textbf{MusicBrainz} estando o mesmo em JSON. O seu timestamp é de 2019-04-03, portanto um dataset bastante recente possuindo cerca de 240GB de tamanho. Visto o mesmo estar em JSON é necessário então convertê-lo para Turtle.

Num primeiro passo, percorre-se os ficheiros JSON (que em cada linha possui um elemento do tipo igual ao nome do ficheiro a percorrer) com os conversores criados em \textit{Node.js}. Foi criado um conversor por ficheiro a converter (que contém informação necessária). Apresentam-se os seguintes conversores, que para cada linha do ficheiro converte a informação para (origem $\to$ destino)~\cite{mbSchema,mbRels}:
\begin{itemize}
    \item Conversor para area.json (\textit{jsonTOturtle/area.js})~\cite{mbAr}:
        \begin{itemize}
            \item \textit{id} $\to$ ``area\_'' + \textit{id} de forma a identificar o indivíduo
            \item \textit{name} $\to$ \textit{data property} \textit{\textbf{name}}
            \item \textit{type} $\to$ \textit{data property} \textit{\textbf{type}}
            \item \textit{aliases} (lista em que de cada elemento usa-se o \textit{name} e o \textit{locale}) $\to$ \textit{data property} \textit{\textbf{alias}} (um por elemento da lista no seguinte formato: ``\textit{name}(\textit{locale})'')
            \item \textit{life-span.begin} $\to$ \textit{data property} \textit{\textbf{beginDate}}
            \item \textit{life-span.end} $\to$ \textit{data property} \textit{\textbf{endDate}}
            \item \textit{annotation} $\to$ \textit{data property} \textit{\textbf{about}}
            \item \textit{disambiguation} $\to$ \textit{data property} \textit{\textbf{disambiguation}}
            \item \textit{relations} (lista) em que os elementos que possuirem:
                \begin{itemize}
                    \item \textit{type} igual a ``part of'' ou item \textit{area}: são transformados em relações entre indivíduos áreas usando \textit{area.id} para saber qual o id da área destino; para além disso, observa-se a \textit{direction} por forma a saber a direção da relação $\to$ \textit{object property} \textit{\textbf{partOf}} (\textit{direction} ``backward'') ou \textit{\textbf{hasPart}} (\textit{direction} ``forward'')
                    \item item \textit{url}: guarda-se o \textit{url.id} (identificador do url: ``url\_'' + \textit{url.id}), \textit{type} (\textit{\textbf{label}} de URL) e \textit{url.resource} (\textit{\textbf{value}} de URL) por forma a posterior criação do indivíduo URL e usa-se \textit{url.id} para criar a relação entre area e URL a ser criada $\to$ \textit{object property} \textit{\textbf{hasURL}}
                \end{itemize}
        \end{itemize}
    \item Conversor para artist.json (\textit{jsonTOturtle/artist.js})~\cite{mbArt}:
        \begin{itemize}
            \item \textit{id} $\to$ ``artist\_'' + \textit{id} de forma a identificar o indivíduo
            \item \textit{area.id} $\to$ \textit{object property} \textit{\textbf{from}}
            \item \textit{name} $\to$ \textit{data property} \textit{\textbf{name}}
            \item \textit{type} $\to$ \textit{data property} \textit{\textbf{type}}
            \item \textit{aliases} (lista em que de cada elemento usa-se o \textit{name} e o \textit{locale}) $\to$ \textit{data property} \textit{\textbf{alias}} (um por elemento da lista no seguinte formato: ``\textit{name}(\textit{locale})'')
            \item \textit{life-span.begin} $\to$ \textit{data property} \textit{\textbf{beginDate}}
            \item \textit{life-span.end} $\to$ \textit{data property} \textit{\textbf{endDate}}
            \item \textit{annotation} $\to$ \textit{data property} \textit{\textbf{about}}
            \item \textit{disambiguation} $\to$ \textit{data property} \textit{\textbf{disambiguation}}
            \item \textit{sort-name} $\to$ \textit{data property} \textit{\textbf{sortName}}
            \item \textit{gender} $\to$ \textit{data property} \textit{\textbf{gender}}
            \item \textit{relations} (lista) em que os elementos que possuirem:
                \begin{itemize}
                    \item item \textit{url}: guarda-se o \textit{url.id} (identificador do url: ``url\_'' + \textit{url.id}), \textit{type} (\textit{\textbf{label}} de URL) e \textit{url.resource} (\textit{\textbf{value}} de URL) por forma a posterior criação do indivíduo URL e usa-se \textit{url.id} para criar a relação entre area e URL a ser criada $\to$ \textit{object property} \textit{\textbf{hasURL}}
                \end{itemize}
        \end{itemize}
    \item Conversor para recording.json (\textit{jsonTOturtle/recording.js})~\cite{mbRec}:
        \begin{itemize}
            \item \textit{id} $\to$ ``recording\_'' + \textit{id} de forma a identificar o indivíduo
            \item \textit{title} $\to$ \textit{data property} \textit{\textbf{title}}
            \item \textit{length} $\to$ \textit{data property} \textit{\textbf{duration}}
            \item \textit{annotation} $\to$ \textit{data property} \textit{\textbf{about}}
            \item \textit{disambiguation} $\to$ \textit{data property} \textit{\textbf{disambiguation}}
            \item \textit{tag} (lista, em que para cada elemento usa-se \textit{name}) $\to$ \textit{data property} \textit{\textbf{tag}} (um por cada elemento da lista)
            \item \textit{artist-credit} (lista, para cada elemento uso \textit{artist.id} de forma a associar ao artista) $\to$ \textit{object property} \textit{\textbf{artistCredit}}
            \item \textit{relations} (lista) em que os elementos que possuirem:
                \begin{itemize}
                    \item item \textit{url}: guarda-se o \textit{url.id} (identificador do url: ``url\_'' + \textit{url.id}), \textit{type} (\textit{\textbf{label}} de URL) e \textit{url.resource} (\textit{\textbf{value}} de URL) por forma a posterior criação do indivíduo URL e usa-se \textit{url.id} para criar a relação entre area e URL a ser criada $\to$ \textit{object property} \textit{\textbf{hasURL}}
                    \item \textit{type} igual a ``performance'': usa-se o \textit{language} e \textit{languages} (lista) $\to$ \textit{data property} \textit{\textbf{language}} (por cada elemento)
                \end{itemize}
        \end{itemize}
    \item Conversor para release-group.json (\textit{jsonTOturtle/release-group.js})~\cite{mbReGp}:
        \begin{itemize}
            \item \textit{id} $\to$ ``album\_'' + \textit{id} de forma a identificar o indivíduo
            \item \textit{title} $\to$ \textit{data property} \textit{\textbf{title}}
            \item \textit{first-release-date} $\to$ \textit{data property} \textit{\textbf{firstReleaseDate}}
            \item \textit{annotation} $\to$ \textit{data property} \textit{\textbf{about}}
            \item \textit{disambiguation} $\to$ \textit{data property} \textit{\textbf{disambiguation}}
            \item \textit{relations} (lista) em que os elementos que possuirem:
                \begin{itemize}
                    \item item \textit{url}: guarda-se o \textit{url.id} (identificador do url: ``url\_'' + \textit{url.id}), \textit{type} (\textit{\textbf{label}} de URL) e \textit{url.resource} (\textit{\textbf{value}} de URL) por forma a posterior criação do indivíduo URL e usa-se \textit{url.id} para criar a relação entre area e URL a ser criada $\to$ \textit{object property} \textit{\textbf{hasURL}}
                \end{itemize}
        \end{itemize}
    \item Conversor para release.json (\textit{jsonTOturtle/release.js})~\cite{mbRe}:
        \begin{itemize}
            \item \textit{release-group.id}
            \item \textit{media} (lista, em que \textit{tracks} (lista) possui recordings e para cada recording usar \textit{recording.id} de forma a criar a relação entre album (\textit{release-group.id}) e recording; para além disso para cada recording realizar o mesmo que em recording.json) $\to$ \textit{object property} \textit{\textbf{hasTrack}}
        \end{itemize}
    \item Conversor para work.json (\textit{jsonTOturtle/work.js})~\cite{mbWo}:
        \begin{itemize}
            \item \textit{language}
            \item \textit{languages} (lista)
            \item \textit{relations} (lista) em que os elementos que possuirem:
                \begin{itemize}
                    \item \textit{type} igual a ``performance'': usa-se o \textit{recording.id} para o id destino do recording $\to$ \textit{data property} \textit{\textbf{language}} (por cada elemento para o id a recording possui \textit{language} e \textit{languages})
                \end{itemize}
        \end{itemize}
\end{itemize}

Ainda nestes conversores, os ids são verificados, visto que, acontece haver ``merges'' de entidades no \textbf{MusicBrainz} e, quando isso acontece passa a existir uma só entidade das duas mas, é possível aceder à mesma através dos dois ids de cada entidade antes do ``merge''. De tal forma, para obter uma ontologia consistente, os ids quando aparecem nos conversores é acedido o URL \url{https://musicbrainz.org/ws/2/entidade/id} através do axios e do campo \texttt{data} verifica-se o campo \texttt{id}. Caso consiga-se obter resposta usa-se o id obtido, caso contrário (pode acontecer por exemplo quando a entidade não existe num dataset mais recente), mantém-se o atual. Contudo, o acesso através deste URL tem uma grande limitação, apenas se pode realizar um pedido a cada segundo, devido a restrições impostas pelo \textbf{MusicBrainz}~\cite{mbLimit}. 

Portanto, por forma a contornar este obstáculo, obteu-se a máquina virtual disponibilizada em \url{ftp://ftp.eu.metabrainz.org/pub/musicbrainz-vm/musicbrainz-server-2018-08-14.ova} ou através do \textit{torrent} disponibilizado em \url{ftp://ftp.eu.metabrainz.org/pub/musicbrainz-vm/musicbrainz-server-2018-08-14.ova.torrent}. Esta máquina virtual possui o servidor do MusicBrainz já pronto a correr, bastando apenas iniciar a máquina virtual e iniciar login com username e password igual a vagrant~\cite{mbSetup}. Contudo, como o dataset que vinha com o servidor da máquina virtual era anterior ao dataset em que o trabalho se baseia, foi atualizado o mesmo ao correr os seguintes comandos na máquina virtual~\cite{mbUpdate}:

\begin{framed}
\begin{minted}{bash}
    cd musicbrainz/musicbrainz-docker
    docker-compose exec musicbrainz /recreatedb.sh -fetch
\end{minted}
\end{framed}

Assim, por forma a usar a máquina virtual em vez do servidor oficial do \textit{MusicBrainz} e evitando assim a limitação do mesmo, basta aceder o URL \url{http://localhost:5000/ws/2/entidade/id} em vez do anteriormente referido.

Por forma a automatizar os conversores, estes podem ser chamados ao correr a script \textit{convert.sh} que chama cada conversor, redirecionando o \textit{output} para um ficheiro \textit{Turtle} (\textit{.ttl}) por conversor. É importante referir também que não houve uso de dados provenientes de series.json (conjuntos de releases-groups), label.json (editoras de música, discografias, etc), place.json (locais de produção de música), event.json (eventos de música, festivais, etc) e instrument.json (instrumentos).

Por fim, concatena-se os vários ficheiros gerados e o ficheiro com a estrutura gerando um ficheiro Turtle final, passível de ser carregado no \textit{GraphDB}.

~\cite{mbAnnotation}

\section{Conclusão}

\newpage 
\printbibliography

\begin{appendices}

\end{appendices}

\end{document}
